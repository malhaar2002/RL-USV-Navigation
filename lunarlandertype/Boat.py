import pygame
import numpy as np
from FlowField import FlowField

class Boat(pygame.sprite.Sprite):
    def __init__(self, x, y):
        super().__init__()
        self.original_image = pygame.image.load("assets/boat.png")  # Replace with your boat sprite path
        self.original_image = pygame.transform.scale(self.original_image, (70, 70))
        self.image = self.original_image
        self.rect = self.image.get_rect(center=(x, y))
        self.position = (x, y)
        self.angle = 0
        self.velocity_x = 0
        self.velocity_y = 0
        self.angular_velocity = 0
        self.MASS = 10
        self.THROTTLE_POSITION = 0.5 # Throttle position (0: center, 1: end)
        self.THROTTLE_LENGTH = 1.0 # Throttle length (meters)
        self.INERTIA = 5000 # Moment of inertia (kg * m^2)

    def update(self):
        # Rotate the boat image
        # self.image = pygame.transform.rotate(self.original_image, self.angle)
        self.image = pygame.transform.rotate(self.original_image, -self.angle)
        self.rect = self.image.get_rect(center=self.rect.center)


    def move(self, flow_field: 'FlowField', dt: float, action: list[int]):
        # Get the flow direction at the current position
        flow_direction = flow_field.get_flow_direction(self.rect.x, self.rect.y)
        
        # Calculate the force components based on the flow direction
        flow_vel_x = flow_field.velocity * np.cos(flow_direction)
        flow_vel_y = flow_field.velocity * np.sin(flow_direction)

        left_thruster_force, right_thruster_force = action

        # Calculate the total force components from thrusters
        total_force_x = left_thruster_force * np.cos(np.radians(self.angle)) + right_thruster_force * np.cos(np.radians(self.angle))
        total_force_y = left_thruster_force * np.sin(np.radians(self.angle)) + right_thruster_force * np.sin(np.radians(self.angle))

        # Calculate the torque generated by each thruster
        torque_left = left_thruster_force * self.THROTTLE_POSITION * self.THROTTLE_LENGTH
        torque_right = right_thruster_force * self.THROTTLE_POSITION * self.THROTTLE_LENGTH

        # Calculate the angular acceleration
        angular_acceleration = (torque_right - torque_left) / self.INERTIA

        # Update the angular velocity and angle
        self.angular_velocity += angular_acceleration * dt
        self.angle -= (self.angular_velocity * dt) * 60 # randomly multiplied by 60 to scale up the rotation

        # Calculate the displacement using kinematic equations
        displacement_x = (self.velocity_x + flow_vel_x) * dt + 0.5 * (total_force_x) / self.MASS * dt**2
        displacement_y = (self.velocity_y + flow_vel_y) * dt + 0.5 * (total_force_y) / self.MASS * dt**2

        # Update the velocity using the change in force
        self.velocity_x += (total_force_x) / self.MASS * dt
        self.velocity_y += (total_force_y) / self.MASS * dt
        
        # Update the boat's position
        if displacement_x < 0:
            displacement_x = np.ceil(displacement_x)
        else:
            displacement_x = np.floor(displacement_x)
        if displacement_y < 0:
            displacement_y = np.ceil(displacement_y)
        else:
            displacement_y = np.floor(displacement_y)
        self.rect.x += displacement_x
        self.rect.y += displacement_y